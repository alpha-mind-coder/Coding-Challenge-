So we recently did a similar but just opposite problem of merge sort that is quick sort
  "QUICK SORT"
  CODE:-


#include <iostream>
using namespace std;

int partition(int arr[], int s, int e) {
    int pivot = arr[s];
    int cnt=0;

    for (int j = s+1; j <=e; j++) {
        if (arr[j] <= pivot) {
           cnt++;
        }
    }
   int pivotidx = cnt+s;
    swap(arr[pivotidx], arr[s]);  
    int i=s,j=e;
    while(i<pivotidx && j>pivotindex){
       while(arr[i]<=pivotidx){
         i++;
       }
       while(arr[i]>pivotidx){
         j--;
       }
      if(i<pivotidx && j>pivotindex){
        swap(arr[i++],arr[j--]);}
    }
    
    }
return pivotidx;

}

void quickSort(int arr[], int s, int e) {
    if (s < =e) { return };
        int pi = partition(arr, s,e);

        quickSort(arr, s, pi - 1);
        quickSort(arr, pi + 1, e);

}

int main() {
    int arr[] = {10, 7, 8, 9, 1, 5};
    int n = sizeof(arr) / sizeof(arr[0]);

    quickSort(arr, 0, n - 1);

    cout << "Sorted array: ";
    for (int i = 0; i < n; i++) {
        cout << arr[i] << " ";
    }
    return 0;
}
